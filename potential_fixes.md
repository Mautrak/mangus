## 1. Byte Order Mark (BOM) in Username Input
- **Issue:** Client (Mudlet) sends username prefixed with a UTF-16 LE BOM (`\xff\xfe`), e.g., `\xff\xfeeredanne`.
- **Symptom:** The `check_parse_name` function in `comm.c` rejects the name because the BOM characters are not alphabetic, leading to an "invalid name" message.
- **Location:** `nanny` function in `comm.c` calls `check_parse_name`. `d->incomm` (which `argument` points into) holds the BOM-prefixed name during `CON_GET_NAME` state.
- **Diagnosis Update:** The issue is confirmed to be the BOM characters themselves.
- **Potential Fix (Refined):** In the `nanny` function (`comm.c`), within the `CON_GET_NAME` state and after skipping leading whitespace, add logic to inspect the initial bytes of the `argument`. If these bytes match known BOM sequences (UTF-8: `EF BB BF`; UTF-16 LE: `FF FE`; UTF-16 BE: `FE FF`), advance the `argument` pointer by the length of the BOM (3 or 2 bytes respectively). This ensures `check_parse_name` receives the username without the BOM prefix.

## 2. Incomplete Telnet Character Set (TELOPT_CHARSET) Negotiation
- **Issue:** Server sends `IAC WILL TELOPT_CHARSET` but does not implement the subsequent subnegotiation (e.g., `IAC SB TELOPT_CHARSET REQUEST "UTF-8" IAC SE`) to agree on a specific charset.
- **Symptom:** May cause connection instability or incorrect charset handling by some MUD clients (e.g., observed "Connection reset by peer" errors with Mudlet). The client might not switch to the server's intended charset (e.g., UTF-8) if negotiation is incomplete.
- **Location:** `init_descriptor` function in `comm.c`.
- **Diagnosis Update:** Confirmed that incomplete negotiation is problematic.
- **Potential Fix (Refined):**
    - **Primary Recommendation (Simpler Interim):** In `init_descriptor()` (`comm.c`), remove or comment out the line that sends `IAC WILL TELOPT_CHARSET`. The server should continue to send `IAC WILL TELOPT_BINARY`, which is generally sufficient for UTF-8 passthrough, and rely on clients defaulting to or being configured for UTF-8.
    - **Safer Telnet Commands:** When sending any Telnet command sequences using the `write()` system call, ensure the buffer containing the IAC codes is an array of `unsigned char` to correctly handle values greater than 127. Cast this buffer to `(const void *)` or `(char *)` as required by the `write()` function signature.

## 3. Telnet IAC GA in Prompt (Original Core Issue - Not Discussed in Detail This Session)
- **Issue:** If `COMM_TELNET_GA` is set for a player, `IAC GA` is sent *after* the prompt. Some clients (e.g., Mudlet, some Windows telnets) might interpret `IAC GA` as "clear current line and print next prompt," effectively eating the game's prompt.
- **Symptom:** Prompt doesn't display, or displays then immediately disappears. Input might seem to be on a blank line.
- **Location:** `process_output` function in `comm.c`, specifically the part that handles `COMM_TELNET_GA`.
- **Potential Fix (Original Hypothesis - Needs Verification/Refinement if pursued):** Modify `process_output()` to send the `IAC GA` sequence *before* the prompt string itself is written to the output buffer, rather than after. This aligns better with the Go-Ahead's purpose. Alternatively, consider making `COMM_TELNET_GA` off by default or providing user education, as many modern clients handle prompting without explicit GA.
    *Further investigation needed if this is still a priority.*

## 4. Appended Garbage Mojibake (Original Core Issue)
- **Issue:** Seemingly random garbage characters (e.g., `A @ `, `k @ `, `&!@ `, `�/( `) are appended to various game strings like room names (e.g., in `area_stat.txt`), item descriptions, and other text.
- **Symptom:** Corrupted text display for players, making parts of the game unreadable or confusing.
- **Location:** Initially suspected in color handling (`colourconv`, `act_color`, etc. in `comm.c`) or string loading (`fread_string` in `db.c`).
- **Diagnosis Update & Pinpointed Cause:**
    - Hex dump analysis of `.are` files confirmed that some source strings (e.g., "Kaos Çemberi") are clean and correctly UTF-8 encoded in the files.
    - The **primary culprit** was identified in the string interning logic within `fread_string()` in `db.c`. Specifically, when a new unique string is added to the shared `string_space` buffer during boot (`fBootDb` is true), the `top_string` pointer (which tracks the next free position in `string_space`) was being set to point *at* the null terminator of the newly added string. It should point to the byte *after* the null terminator. This error caused the metadata (a hash pointer) for the *next* allocated string to overwrite the null terminator of the *current* string. Consequently, when the current string was later used (e.g., printed), functions like `fprintf %s` would read past its intended end, interpreting the subsequent hash pointer bytes as part of the string, which then appeared as garbage characters.
- **Potential Fix (Refined and Targeted):**
    1.  **Critical Fix for `fread_string()` in `db.c`:** In the section of `fread_string()` that handles adding a new string to the `string_space` (within the `case '~':` and `if (fBootDb)` block), modify the line that updates `top_string`. Instead of `top_string = plast;`, it should be `top_string = plast + 1;`. This ensures `top_string` correctly points to the next available free byte *after* the null terminator of the string just processed and interned. Also, add a boundary check to ensure `top_string` does not exceed `string_space + MAX_STRING`.
    2.  **Complementary Robustness Fix for `colour()` and `colourconv()` in `comm.c`:** The original `colour()` and `colourconv()` functions used pointer arithmetic (`*++string = '\0'` and similar in `colourconv`) that, while not the primary cause of *this* specific garbage issue, is inherently risky and could lead to other string corruption. Refactor these functions to use safer methods for building the output string. For `colour()`, it should fill a local buffer with the ANSI sequence and then copy that sequence to the provided output pointer, returning the length of the code written. For `colourconv()`, it should iterate through the input, and when a color code is encountered, call the revised `colour()` to append the ANSI sequence to its output buffer, advancing its output buffer pointer by the length returned by `colour()`. Regular characters should be copied directly. The final output buffer in `colourconv` must be explicitly null-terminated.
    3.  **Source Data Encoding Consistency:** While the "Kaos Çemberi" example was found to be clean UTF-8, it remains crucial to ensure that *all* `.are` files and other string data sources are consistently encoded in UTF-8. This will prevent unrelated instances of `�` (Unicode Replacement Character) that can occur when legacy encoded characters (e.g., from ISO-8859-9 or CP1254 for Turkish) are misinterpreted as invalid UTF-8 sequences.
